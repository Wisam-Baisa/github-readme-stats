Big O notation is used to describe the performance or complexity of an algorithm in terms of time or space required as the input size grows. It focuses on the worst-case scenario and ignores constants and lower-order terms.

Common Big O Complexities:
O(1) - Constant Time: The algorithm takes the same amount of time regardless of the size of the input.
Example: Accessing an element in an array by index.

O(log n) - Logarithmic Time: The algorithm's time grows logarithmically as the input size increases.
Example: Binary search in a sorted array.

O(n) - Linear Time: The algorithm's time grows linearly with the input size.
Example: Iterating through an array or list.

O(n^2) - Quadratic Time: The algorithm's time grows quadratically with the input size.
Example: Bubble sort or insertion sort.

O(2^n) - Exponential Time: The algorithm's time grows exponentially with the input size.
Example: Recursive algorithms with multiple calls, like the naive Fibonacci sequence calculation.

Example:
Consider a simple loop:

java
Copy
Edit
for(int i = 0; i < n; i++) {
    // some constant time operation
}
